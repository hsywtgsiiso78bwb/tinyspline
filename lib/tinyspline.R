# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 /usr/local/bin/swig -r -O -outdir /home/travis/build/msteinbeck/tinyspline/tools/ci/build/src/r -c++ -I/home/travis/build/msteinbeck/tinyspline/src -I/usr/include/python3.5m -I/usr/lib/jvm/java-8-openjdk-amd64/include -I/usr/lib/jvm/java-8-openjdk-amd64/include/linux -I/home/travis/.rvm/rubies/ruby-2.5.3/include/ruby-2.5.0 -I/home/travis/.rvm/rubies/ruby-2.5.3/include/ruby-2.5.0/x86_64-linux -I/usr/include/lua5.3 -I/usr/include/octave-4.0.0/octave -I/usr/include/octave-4.0.0 -I/usr/share/R/include -I/usr/lib/R/site-library/Rcpp/include -o /home/travis/build/msteinbeck/tinyspline/tools/ci/build/src/r/tinysplinerR_wrap.cxx /home/travis/build/msteinbeck/tinyspline/src/tinyspliner.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_tinyspline__DeBoorNet', contains = 'C++Reference')
setClass('_p_tinyspline__Domain', contains = 'C++Reference')
setClass('_p_tinyspline__BSpline', contains = 'C++Reference')
setClass('_p_tinyspline__Utils', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

defineEnumeration('_tsBSplineType',
                    .values = c(
                        'TS_OPENED' = 0, 
                        'TS_CLAMPED' = 1, 
                        'TS_BEZIERS' = 2
))
# Start of ts_bspline_degree

`ts_bspline_degree` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_degree', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_degree`, 'returnType') = 'integer'
attr(`ts_bspline_degree`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_degree`) = c("SWIGFunction", class('ts_bspline_degree'))

# Start of ts_bspline_set_degree

`ts_bspline_set_degree` = function(spline, deg, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_set_degree', spline, deg, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_set_degree`, 'returnType') = 'character'
attr(`ts_bspline_set_degree`, "inputTypes") = c('_p_tsBSpline', 'integer', '_p_tsStatus')
class(`ts_bspline_set_degree`) = c("SWIGFunction", class('ts_bspline_set_degree'))

# Start of ts_bspline_order

`ts_bspline_order` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_order', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_order`, 'returnType') = 'integer'
attr(`ts_bspline_order`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_order`) = c("SWIGFunction", class('ts_bspline_order'))

# Start of ts_bspline_set_order

`ts_bspline_set_order` = function(spline, order, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_set_order', spline, order, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_set_order`, 'returnType') = 'character'
attr(`ts_bspline_set_order`, "inputTypes") = c('_p_tsBSpline', 'integer', '_p_tsStatus')
class(`ts_bspline_set_order`) = c("SWIGFunction", class('ts_bspline_set_order'))

# Start of ts_bspline_dimension

`ts_bspline_dimension` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_dimension', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_dimension`, 'returnType') = 'integer'
attr(`ts_bspline_dimension`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_dimension`) = c("SWIGFunction", class('ts_bspline_dimension'))

# Start of ts_bspline_set_dimension

`ts_bspline_set_dimension` = function(spline, dim, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  dim = as.integer(dim);
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_set_dimension', spline, dim, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_set_dimension`, 'returnType') = 'character'
attr(`ts_bspline_set_dimension`, "inputTypes") = c('_p_tsBSpline', 'integer', '_p_tsStatus')
class(`ts_bspline_set_dimension`) = c("SWIGFunction", class('ts_bspline_set_dimension'))

# Start of ts_bspline_len_control_points

`ts_bspline_len_control_points` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_len_control_points', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_len_control_points`, 'returnType') = 'integer'
attr(`ts_bspline_len_control_points`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_len_control_points`) = c("SWIGFunction", class('ts_bspline_len_control_points'))

# Start of ts_bspline_num_control_points

`ts_bspline_num_control_points` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_num_control_points', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_num_control_points`, 'returnType') = 'integer'
attr(`ts_bspline_num_control_points`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_num_control_points`) = c("SWIGFunction", class('ts_bspline_num_control_points'))

# Start of ts_bspline_sof_control_points

`ts_bspline_sof_control_points` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_sof_control_points', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_sof_control_points`, 'returnType') = 'integer'
attr(`ts_bspline_sof_control_points`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_sof_control_points`) = c("SWIGFunction", class('ts_bspline_sof_control_points'))

# Start of ts_bspline_control_points

`ts_bspline_control_points` = function(spline, ctrlp, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  if (inherits(ctrlp, "ExternalReference")) ctrlp = slot(ctrlp,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_control_points', spline, ctrlp, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_control_points`, 'returnType') = 'character'
attr(`ts_bspline_control_points`, "inputTypes") = c('_p_tsBSpline', '_p_p_double', '_p_tsStatus')
class(`ts_bspline_control_points`) = c("SWIGFunction", class('ts_bspline_control_points'))

# Start of ts_bspline_control_point_at

`ts_bspline_control_point_at` = function(spline, index, ctrlp, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  if (inherits(ctrlp, "ExternalReference")) ctrlp = slot(ctrlp,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_control_point_at', spline, index, ctrlp, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_control_point_at`, 'returnType') = 'character'
attr(`ts_bspline_control_point_at`, "inputTypes") = c('_p_tsBSpline', 'integer', '_p_p_double', '_p_tsStatus')
class(`ts_bspline_control_point_at`) = c("SWIGFunction", class('ts_bspline_control_point_at'))

# Start of ts_bspline_set_control_points

`ts_bspline_set_control_points` = function(spline, ctrlp, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_set_control_points', spline, ctrlp, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_set_control_points`, 'returnType') = 'character'
attr(`ts_bspline_set_control_points`, "inputTypes") = c('_p_tsBSpline', 'numeric', '_p_tsStatus')
class(`ts_bspline_set_control_points`) = c("SWIGFunction", class('ts_bspline_set_control_points'))

# Start of ts_bspline_set_control_point_at

`ts_bspline_set_control_point_at` = function(spline, index, ctrlp, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_set_control_point_at', spline, index, ctrlp, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_set_control_point_at`, 'returnType') = 'character'
attr(`ts_bspline_set_control_point_at`, "inputTypes") = c('_p_tsBSpline', 'integer', 'numeric', '_p_tsStatus')
class(`ts_bspline_set_control_point_at`) = c("SWIGFunction", class('ts_bspline_set_control_point_at'))

# Start of ts_bspline_num_knots

`ts_bspline_num_knots` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_num_knots', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_num_knots`, 'returnType') = 'integer'
attr(`ts_bspline_num_knots`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_num_knots`) = c("SWIGFunction", class('ts_bspline_num_knots'))

# Start of ts_bspline_sof_knots

`ts_bspline_sof_knots` = function(spline, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_sof_knots', spline, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_sof_knots`, 'returnType') = 'integer'
attr(`ts_bspline_sof_knots`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_sof_knots`) = c("SWIGFunction", class('ts_bspline_sof_knots'))

# Start of ts_bspline_knots

`ts_bspline_knots` = function(spline, knots, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  if (inherits(knots, "ExternalReference")) knots = slot(knots,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_knots', spline, knots, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_knots`, 'returnType') = 'character'
attr(`ts_bspline_knots`, "inputTypes") = c('_p_tsBSpline', '_p_p_double', '_p_tsStatus')
class(`ts_bspline_knots`) = c("SWIGFunction", class('ts_bspline_knots'))

# Start of ts_bspline_set_knots

`ts_bspline_set_knots` = function(spline, knots, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_set_knots', spline, knots, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_set_knots`, 'returnType') = 'character'
attr(`ts_bspline_set_knots`, "inputTypes") = c('_p_tsBSpline', 'numeric', '_p_tsStatus')
class(`ts_bspline_set_knots`) = c("SWIGFunction", class('ts_bspline_set_knots'))

# Start of ts_deboornet_knot

`ts_deboornet_knot` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_knot', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_knot`, 'returnType') = 'numeric'
attr(`ts_deboornet_knot`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_knot`) = c("SWIGFunction", class('ts_deboornet_knot'))

# Start of ts_deboornet_index

`ts_deboornet_index` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_index', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_index`, 'returnType') = 'integer'
attr(`ts_deboornet_index`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_index`) = c("SWIGFunction", class('ts_deboornet_index'))

# Start of ts_deboornet_multiplicity

`ts_deboornet_multiplicity` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_multiplicity', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_multiplicity`, 'returnType') = 'integer'
attr(`ts_deboornet_multiplicity`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_multiplicity`) = c("SWIGFunction", class('ts_deboornet_multiplicity'))

# Start of ts_deboornet_num_insertions

`ts_deboornet_num_insertions` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_num_insertions', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_num_insertions`, 'returnType') = 'integer'
attr(`ts_deboornet_num_insertions`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_num_insertions`) = c("SWIGFunction", class('ts_deboornet_num_insertions'))

# Start of ts_deboornet_dimension

`ts_deboornet_dimension` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_dimension', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_dimension`, 'returnType') = 'integer'
attr(`ts_deboornet_dimension`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_dimension`) = c("SWIGFunction", class('ts_deboornet_dimension'))

# Start of ts_deboornet_len_points

`ts_deboornet_len_points` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_len_points', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_len_points`, 'returnType') = 'integer'
attr(`ts_deboornet_len_points`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_len_points`) = c("SWIGFunction", class('ts_deboornet_len_points'))

# Start of ts_deboornet_num_points

`ts_deboornet_num_points` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_num_points', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_num_points`, 'returnType') = 'integer'
attr(`ts_deboornet_num_points`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_num_points`) = c("SWIGFunction", class('ts_deboornet_num_points'))

# Start of ts_deboornet_sof_points

`ts_deboornet_sof_points` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_sof_points', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_sof_points`, 'returnType') = 'integer'
attr(`ts_deboornet_sof_points`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_sof_points`) = c("SWIGFunction", class('ts_deboornet_sof_points'))

# Start of ts_deboornet_points

`ts_deboornet_points` = function(net, points, status, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  if (inherits(points, "ExternalReference")) points = slot(points,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_deboornet_points', net, points, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_deboornet_points`, 'returnType') = 'character'
attr(`ts_deboornet_points`, "inputTypes") = c('_p_tsDeBoorNet', '_p_p_double', '_p_tsStatus')
class(`ts_deboornet_points`) = c("SWIGFunction", class('ts_deboornet_points'))

# Start of ts_deboornet_len_result

`ts_deboornet_len_result` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_len_result', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_len_result`, 'returnType') = 'integer'
attr(`ts_deboornet_len_result`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_len_result`) = c("SWIGFunction", class('ts_deboornet_len_result'))

# Start of ts_deboornet_num_result

`ts_deboornet_num_result` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_num_result', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_num_result`, 'returnType') = 'integer'
attr(`ts_deboornet_num_result`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_num_result`) = c("SWIGFunction", class('ts_deboornet_num_result'))

# Start of ts_deboornet_sof_result

`ts_deboornet_sof_result` = function(net, .copy = FALSE)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_sof_result', net, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_sof_result`, 'returnType') = 'integer'
attr(`ts_deboornet_sof_result`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_sof_result`) = c("SWIGFunction", class('ts_deboornet_sof_result'))

# Start of ts_bspline_init

`ts_bspline_init` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_ts_bspline_init', as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tsBSpline", ref=ans);
  
  ans
  
}

attr(`ts_bspline_init`, 'returnType') = '_p_tsBSpline'
class(`ts_bspline_init`) = c("SWIGFunction", class('ts_bspline_init'))

# Start of ts_bspline_new

`ts_bspline_new` = function(num_control_points, dimension, degree, type, spline, status, .copy = FALSE)
{
  num_control_points = as.integer(num_control_points);
  
  if(length(num_control_points) > 1) {
    warning("using only the first element of num_control_points");
  };
  
  dimension = as.integer(dimension);
  
  if(length(dimension) > 1) {
    warning("using only the first element of dimension");
  };
  
  degree = as.integer(degree);
  
  if(length(degree) > 1) {
    warning("using only the first element of degree");
  };
  
  type = enumToInteger(type, "_tsBSplineType"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_new', num_control_points, dimension, degree, type, spline, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_new`, 'returnType') = 'character'
attr(`ts_bspline_new`, "inputTypes") = c('integer', 'integer', 'integer', 'character', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_new`) = c("SWIGFunction", class('ts_bspline_new'))

# Start of ts_bspline_copy

`ts_bspline_copy` = function(src, dest, status, .copy = FALSE)
{
  if (inherits(src, "ExternalReference")) src = slot(src,"ref") 
  if (inherits(dest, "ExternalReference")) dest = slot(dest,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_copy', src, dest, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_copy`, 'returnType') = 'character'
attr(`ts_bspline_copy`, "inputTypes") = c('_p_tsBSpline', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_copy`) = c("SWIGFunction", class('ts_bspline_copy'))

# Start of ts_bspline_move

`ts_bspline_move` = function(src, dest)
{
  if (inherits(src, "ExternalReference")) src = slot(src,"ref") 
  if (inherits(dest, "ExternalReference")) dest = slot(dest,"ref") 
  ;.Call('R_swig_ts_bspline_move', src, dest, PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_move`, 'returnType') = 'void'
attr(`ts_bspline_move`, "inputTypes") = c('_p_tsBSpline', '_p_tsBSpline')
class(`ts_bspline_move`) = c("SWIGFunction", class('ts_bspline_move'))

# Start of ts_bspline_free

`ts_bspline_free` = function(spline)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  ;.Call('R_swig_ts_bspline_free', spline, PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_free`, 'returnType') = 'void'
attr(`ts_bspline_free`, "inputTypes") = c('_p_tsBSpline')
class(`ts_bspline_free`) = c("SWIGFunction", class('ts_bspline_free'))

# Start of ts_deboornet_init

`ts_deboornet_init` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_ts_deboornet_init', as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tsDeBoorNet", ref=ans);
  
  ans
  
}

attr(`ts_deboornet_init`, 'returnType') = '_p_tsDeBoorNet'
class(`ts_deboornet_init`) = c("SWIGFunction", class('ts_deboornet_init'))

# Start of ts_deboornet_copy

`ts_deboornet_copy` = function(src, dest, status, .copy = FALSE)
{
  if (inherits(src, "ExternalReference")) src = slot(src,"ref") 
  if (inherits(dest, "ExternalReference")) dest = slot(dest,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_deboornet_copy', src, dest, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_deboornet_copy`, 'returnType') = 'character'
attr(`ts_deboornet_copy`, "inputTypes") = c('_p_tsDeBoorNet', '_p_tsDeBoorNet', '_p_tsStatus')
class(`ts_deboornet_copy`) = c("SWIGFunction", class('ts_deboornet_copy'))

# Start of ts_deboornet_move

`ts_deboornet_move` = function(src, dest)
{
  if (inherits(src, "ExternalReference")) src = slot(src,"ref") 
  if (inherits(dest, "ExternalReference")) dest = slot(dest,"ref") 
  ;.Call('R_swig_ts_deboornet_move', src, dest, PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_move`, 'returnType') = 'void'
attr(`ts_deboornet_move`, "inputTypes") = c('_p_tsDeBoorNet', '_p_tsDeBoorNet')
class(`ts_deboornet_move`) = c("SWIGFunction", class('ts_deboornet_move'))

# Start of ts_deboornet_free

`ts_deboornet_free` = function(net)
{
  if (inherits(net, "ExternalReference")) net = slot(net,"ref") 
  ;.Call('R_swig_ts_deboornet_free', net, PACKAGE='tinyspliner');
  
}

attr(`ts_deboornet_free`, 'returnType') = 'void'
attr(`ts_deboornet_free`, "inputTypes") = c('_p_tsDeBoorNet')
class(`ts_deboornet_free`) = c("SWIGFunction", class('ts_deboornet_free'))

# Start of ts_bspline_interpolate_cubic

`ts_bspline_interpolate_cubic` = function(points, n, dim, s_spline_, status, .copy = FALSE)
{
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  dim = as.integer(dim);
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  if (inherits(s_spline_, "ExternalReference")) s_spline_ = slot(s_spline_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_interpolate_cubic', points, n, dim, s_spline_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_interpolate_cubic`, 'returnType') = 'character'
attr(`ts_bspline_interpolate_cubic`, "inputTypes") = c('numeric', 'integer', 'integer', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_interpolate_cubic`) = c("SWIGFunction", class('ts_bspline_interpolate_cubic'))

# Start of ts_bspline_eval

`ts_bspline_eval` = function(spline, u, s_deBoorNet_, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  if (inherits(s_deBoorNet_, "ExternalReference")) s_deBoorNet_ = slot(s_deBoorNet_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_eval', spline, u, s_deBoorNet_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_eval`, 'returnType') = 'character'
attr(`ts_bspline_eval`, "inputTypes") = c('_p_tsBSpline', 'numeric', '_p_tsDeBoorNet', '_p_tsStatus')
class(`ts_bspline_eval`) = c("SWIGFunction", class('ts_bspline_eval'))

# Start of ts_bspline_domain

`ts_bspline_domain` = function(spline, min, max)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  
  ;.Call('R_swig_ts_bspline_domain', spline, min, max, PACKAGE='tinyspliner');
  
}

attr(`ts_bspline_domain`, 'returnType') = 'void'
attr(`ts_bspline_domain`, "inputTypes") = c('_p_tsBSpline', 'numeric', 'numeric')
class(`ts_bspline_domain`) = c("SWIGFunction", class('ts_bspline_domain'))

# Start of ts_bspline_is_closed

`ts_bspline_is_closed` = function(spline, epsilon, closed, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  closed = as.integer(closed);
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_is_closed', spline, epsilon, closed, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_is_closed`, 'returnType') = 'character'
attr(`ts_bspline_is_closed`, "inputTypes") = c('_p_tsBSpline', 'numeric', 'integer', '_p_tsStatus')
class(`ts_bspline_is_closed`) = c("SWIGFunction", class('ts_bspline_is_closed'))

# Start of ts_bspline_derive

`ts_bspline_derive` = function(spline, n, s_derivative_, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(s_derivative_, "ExternalReference")) s_derivative_ = slot(s_derivative_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_derive', spline, n, s_derivative_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_derive`, 'returnType') = 'character'
attr(`ts_bspline_derive`, "inputTypes") = c('_p_tsBSpline', 'integer', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_derive`) = c("SWIGFunction", class('ts_bspline_derive'))

# Start of ts_bspline_insert_knot

`ts_bspline_insert_knot` = function(spline, u, n, s_result_, s_k_, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(s_result_, "ExternalReference")) s_result_ = slot(s_result_,"ref") 
  s_k_ = as.integer(s_k_);
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_insert_knot', spline, u, n, s_result_, s_k_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_insert_knot`, 'returnType') = 'character'
attr(`ts_bspline_insert_knot`, "inputTypes") = c('_p_tsBSpline', 'numeric', 'integer', '_p_tsBSpline', 'integer', '_p_tsStatus')
class(`ts_bspline_insert_knot`) = c("SWIGFunction", class('ts_bspline_insert_knot'))

# Start of ts_bspline_split

`ts_bspline_split` = function(spline, u, s_split_, s_k_, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  if (inherits(s_split_, "ExternalReference")) s_split_ = slot(s_split_,"ref") 
  s_k_ = as.integer(s_k_);
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_split', spline, u, s_split_, s_k_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_split`, 'returnType') = 'character'
attr(`ts_bspline_split`, "inputTypes") = c('_p_tsBSpline', 'numeric', '_p_tsBSpline', 'integer', '_p_tsStatus')
class(`ts_bspline_split`) = c("SWIGFunction", class('ts_bspline_split'))

# Start of ts_bspline_buckle

`ts_bspline_buckle` = function(spline, b, s_buckled_, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  
  if (inherits(s_buckled_, "ExternalReference")) s_buckled_ = slot(s_buckled_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_buckle', spline, b, s_buckled_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_buckle`, 'returnType') = 'character'
attr(`ts_bspline_buckle`, "inputTypes") = c('_p_tsBSpline', 'numeric', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_buckle`) = c("SWIGFunction", class('ts_bspline_buckle'))

# Start of ts_bspline_to_beziers

`ts_bspline_to_beziers` = function(spline, s_beziers_, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  if (inherits(s_beziers_, "ExternalReference")) s_beziers_ = slot(s_beziers_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_to_beziers', spline, s_beziers_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_to_beziers`, 'returnType') = 'character'
attr(`ts_bspline_to_beziers`, "inputTypes") = c('_p_tsBSpline', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_to_beziers`) = c("SWIGFunction", class('ts_bspline_to_beziers'))

# Start of ts_bspline_to_json

`ts_bspline_to_json` = function(spline, s_json_, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  if (inherits(s_json_, "ExternalReference")) s_json_ = slot(s_json_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_to_json', spline, s_json_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_to_json`, 'returnType') = 'character'
attr(`ts_bspline_to_json`, "inputTypes") = c('_p_tsBSpline', 'character', '_p_tsStatus')
class(`ts_bspline_to_json`) = c("SWIGFunction", class('ts_bspline_to_json'))

# Start of ts_bspline_from_json

`ts_bspline_from_json` = function(json, s_spline_, status, .copy = FALSE)
{
  json = as(json, "character"); 
  if (inherits(s_spline_, "ExternalReference")) s_spline_ = slot(s_spline_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_from_json', json, s_spline_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_from_json`, 'returnType') = 'character'
attr(`ts_bspline_from_json`, "inputTypes") = c('character', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_from_json`) = c("SWIGFunction", class('ts_bspline_from_json'))

# Start of ts_bspline_save_json

`ts_bspline_save_json` = function(spline, path, status, .copy = FALSE)
{
  if (inherits(spline, "ExternalReference")) spline = slot(spline,"ref") 
  path = as(path, "character"); 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_save_json', spline, path, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_save_json`, 'returnType') = 'character'
attr(`ts_bspline_save_json`, "inputTypes") = c('_p_tsBSpline', 'character', '_p_tsStatus')
class(`ts_bspline_save_json`) = c("SWIGFunction", class('ts_bspline_save_json'))

# Start of ts_bspline_load_json

`ts_bspline_load_json` = function(path, s_spline_, status, .copy = FALSE)
{
  path = as(path, "character"); 
  if (inherits(s_spline_, "ExternalReference")) s_spline_ = slot(s_spline_,"ref") 
  if (inherits(status, "ExternalReference")) status = slot(status,"ref") 
  ;ans = .Call('R_swig_ts_bspline_load_json', path, s_spline_, status, as.logical(.copy), PACKAGE='tinyspliner');
  ans = enumFromInteger(ans, "_tsError");
  
  ans
  
}

attr(`ts_bspline_load_json`, 'returnType') = 'character'
attr(`ts_bspline_load_json`, "inputTypes") = c('character', '_p_tsBSpline', '_p_tsStatus')
class(`ts_bspline_load_json`) = c("SWIGFunction", class('ts_bspline_load_json'))

# Start of ts_knots_equal

`ts_knots_equal` = function(x, y, .copy = FALSE)
{
  ;.Call('R_swig_ts_knots_equal', x, y, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_knots_equal`, 'returnType') = 'integer'
attr(`ts_knots_equal`, "inputTypes") = c('numeric', 'numeric')
class(`ts_knots_equal`) = c("SWIGFunction", class('ts_knots_equal'))

# Start of ts_arr_fill

`ts_arr_fill` = function(arr, num, val)
{
  num = as.integer(num);
  
  if(length(num) > 1) {
    warning("using only the first element of num");
  };
  
  
  ;.Call('R_swig_ts_arr_fill', arr, num, val, PACKAGE='tinyspliner');
  
}

attr(`ts_arr_fill`, 'returnType') = 'void'
attr(`ts_arr_fill`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`ts_arr_fill`) = c("SWIGFunction", class('ts_arr_fill'))

# Start of ts_distance

`ts_distance` = function(x, y, dim, .copy = FALSE)
{
  dim = as.integer(dim);
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  ;.Call('R_swig_ts_distance', x, y, dim, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`ts_distance`, 'returnType') = 'numeric'
attr(`ts_distance`, "inputTypes") = c('numeric', 'numeric', 'integer')
class(`ts_distance`) = c("SWIGFunction", class('ts_distance'))

# Start of new_DeBoorNet

`DeBoorNet` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_DeBoorNet', other, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__DeBoorNet", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_DeBoorNet)
  ans
  
}

attr(`DeBoorNet`, 'returnType') = '_p_tinyspline__DeBoorNet'
attr(`DeBoorNet`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet`) = c("SWIGFunction", class('DeBoorNet'))

# Start of delete_DeBoorNet

`delete_DeBoorNet` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_DeBoorNet', self, PACKAGE='tinyspliner');
  
}

attr(`delete_DeBoorNet`, 'returnType') = 'void'
attr(`delete_DeBoorNet`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`delete_DeBoorNet`) = c("SWIGFunction", class('delete_DeBoorNet'))

# Start of DeBoorNet_knot_get

`DeBoorNet_knot_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DeBoorNet_knot_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`DeBoorNet_knot_get`, 'returnType') = 'numeric'
attr(`DeBoorNet_knot_get`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet_knot_get`) = c("SWIGFunction", class('DeBoorNet_knot_get'))

# Start of DeBoorNet_index_get

`DeBoorNet_index_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DeBoorNet_index_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`DeBoorNet_index_get`, 'returnType') = 'integer'
attr(`DeBoorNet_index_get`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet_index_get`) = c("SWIGFunction", class('DeBoorNet_index_get'))

# Start of DeBoorNet_multiplicity_get

`DeBoorNet_multiplicity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DeBoorNet_multiplicity_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`DeBoorNet_multiplicity_get`, 'returnType') = 'integer'
attr(`DeBoorNet_multiplicity_get`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet_multiplicity_get`) = c("SWIGFunction", class('DeBoorNet_multiplicity_get'))

# Start of DeBoorNet_numInsertions_get

`DeBoorNet_numInsertions_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DeBoorNet_numInsertions_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`DeBoorNet_numInsertions_get`, 'returnType') = 'integer'
attr(`DeBoorNet_numInsertions_get`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet_numInsertions_get`) = c("SWIGFunction", class('DeBoorNet_numInsertions_get'))

# Start of DeBoorNet_dimension_get

`DeBoorNet_dimension_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DeBoorNet_dimension_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`DeBoorNet_dimension_get`, 'returnType') = 'integer'
attr(`DeBoorNet_dimension_get`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet_dimension_get`) = c("SWIGFunction", class('DeBoorNet_dimension_get'))

# Start of DeBoorNet_points_get

`DeBoorNet_points_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DeBoorNet_points_get', self, PACKAGE='tinyspliner');
  
}

attr(`DeBoorNet_points_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DeBoorNet_points_get`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet_points_get`) = c("SWIGFunction", class('DeBoorNet_points_get'))

# Start of DeBoorNet_result_get

`DeBoorNet_result_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DeBoorNet_result_get', self, PACKAGE='tinyspliner');
  
}

attr(`DeBoorNet_result_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DeBoorNet_result_get`, "inputTypes") = c('_p_tinyspline__DeBoorNet')
class(`DeBoorNet_result_get`) = c("SWIGFunction", class('DeBoorNet_result_get'))

# Start of accessor method for tinyspline::DeBoorNet
setMethod('$', '_p_tinyspline__DeBoorNet', function(x, name)

{
  accessorFuns = list('knot' = DeBoorNet_knot_get, 'index' = DeBoorNet_index_get, 'multiplicity' = DeBoorNet_multiplicity_get, 'numInsertions' = DeBoorNet_numInsertions_get, 'dimension' = DeBoorNet_dimension_get, 'points' = DeBoorNet_points_get, 'result' = DeBoorNet_result_get);
  vaccessors = c('knot', 'index', 'multiplicity', 'numInsertions', 'dimension', 'points', 'result');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for tinyspline::DeBoorNet
setMethod('delete', '_p_tinyspline__DeBoorNet', function(obj) {delete_tinyspline__DeBoorNet(obj)})
# Start of new_Domain

`Domain__SWIG_0` = function(min, max)
{
  ;ans = .Call('R_swig_new_Domain__SWIG_0', min, max, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__Domain", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Domain)
  ans
  
}

attr(`Domain__SWIG_0`, 'returnType') = '_p_tinyspline__Domain'
attr(`Domain__SWIG_0`, "inputTypes") = c('numeric', 'numeric')
class(`Domain__SWIG_0`) = c("SWIGFunction", class('Domain__SWIG_0'))

# Start of new_Domain

`Domain__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_Domain__SWIG_1', other, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__Domain", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Domain)
  ans
  
}

attr(`Domain__SWIG_1`, 'returnType') = '_p_tinyspline__Domain'
attr(`Domain__SWIG_1`, "inputTypes") = c('_p_tinyspline__Domain')
class(`Domain__SWIG_1`) = c("SWIGFunction", class('Domain__SWIG_1'))

`Domain` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_tinyspline__Domain') && length(argv[[1]]) == 1) {
      f <- Domain__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( is.numeric(argv[[1]]) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- Domain__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for Domain with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of Domain_min_get

`Domain_min_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Domain_min_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`Domain_min_get`, 'returnType') = 'numeric'
attr(`Domain_min_get`, "inputTypes") = c('_p_tinyspline__Domain')
class(`Domain_min_get`) = c("SWIGFunction", class('Domain_min_get'))

# Start of Domain_max_get

`Domain_max_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Domain_max_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`Domain_max_get`, 'returnType') = 'numeric'
attr(`Domain_max_get`, "inputTypes") = c('_p_tinyspline__Domain')
class(`Domain_max_get`) = c("SWIGFunction", class('Domain_max_get'))

# Start of delete_Domain

`delete_Domain` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Domain', self, PACKAGE='tinyspliner');
  
}

attr(`delete_Domain`, 'returnType') = 'void'
attr(`delete_Domain`, "inputTypes") = c('_p_tinyspline__Domain')
class(`delete_Domain`) = c("SWIGFunction", class('delete_Domain'))

# Start of accessor method for tinyspline::Domain
setMethod('$', '_p_tinyspline__Domain', function(x, name)

{
  accessorFuns = list('min' = Domain_min_get, 'max' = Domain_max_get);
  vaccessors = c('min', 'max');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for tinyspline::Domain
setMethod('delete', '_p_tinyspline__Domain', function(obj) {delete_tinyspline__Domain(obj)})
# Start of new_BSpline

`BSpline__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_BSpline__SWIG_0', PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BSpline)
  ans
  
}

attr(`BSpline__SWIG_0`, 'returnType') = '_p_tinyspline__BSpline'
class(`BSpline__SWIG_0`) = c("SWIGFunction", class('BSpline__SWIG_0'))

# Start of new_BSpline

`BSpline__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_BSpline__SWIG_1', other, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BSpline)
  ans
  
}

attr(`BSpline__SWIG_1`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline__SWIG_1`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline__SWIG_1`) = c("SWIGFunction", class('BSpline__SWIG_1'))

# Start of new_BSpline

`BSpline__SWIG_2` = function(nCtrlp, dim, deg, type)
{
  nCtrlp = as.integer(nCtrlp);
  
  if(length(nCtrlp) > 1) {
    warning("using only the first element of nCtrlp");
  };
  
  dim = as.integer(dim);
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  type = enumToInteger(type, "_tsBSplineType"); 
  
  if(length(type) > 1) {
    warning("using only the first element of type");
  };
  
  ;ans = .Call('R_swig_new_BSpline__SWIG_2', nCtrlp, dim, deg, type, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BSpline)
  ans
  
}

attr(`BSpline__SWIG_2`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline__SWIG_2`, "inputTypes") = c('integer', 'integer', 'integer', 'character')
class(`BSpline__SWIG_2`) = c("SWIGFunction", class('BSpline__SWIG_2'))

# Start of new_BSpline

`BSpline__SWIG_3` = function(nCtrlp, dim, deg)
{
  nCtrlp = as.integer(nCtrlp);
  
  if(length(nCtrlp) > 1) {
    warning("using only the first element of nCtrlp");
  };
  
  dim = as.integer(dim);
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  deg = as.integer(deg);
  
  if(length(deg) > 1) {
    warning("using only the first element of deg");
  };
  
  ;ans = .Call('R_swig_new_BSpline__SWIG_3', nCtrlp, dim, deg, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BSpline)
  ans
  
}

attr(`BSpline__SWIG_3`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline__SWIG_3`, "inputTypes") = c('integer', 'integer', 'integer')
class(`BSpline__SWIG_3`) = c("SWIGFunction", class('BSpline__SWIG_3'))

# Start of new_BSpline

`BSpline__SWIG_4` = function(nCtrlp, dim)
{
  nCtrlp = as.integer(nCtrlp);
  
  if(length(nCtrlp) > 1) {
    warning("using only the first element of nCtrlp");
  };
  
  dim = as.integer(dim);
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  ;ans = .Call('R_swig_new_BSpline__SWIG_4', nCtrlp, dim, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BSpline)
  ans
  
}

attr(`BSpline__SWIG_4`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline__SWIG_4`, "inputTypes") = c('integer', 'integer')
class(`BSpline__SWIG_4`) = c("SWIGFunction", class('BSpline__SWIG_4'))

# Start of new_BSpline

`BSpline__SWIG_5` = function(nCtrlp)
{
  nCtrlp = as.integer(nCtrlp);
  
  if(length(nCtrlp) > 1) {
    warning("using only the first element of nCtrlp");
  };
  
  ;ans = .Call('R_swig_new_BSpline__SWIG_5', nCtrlp, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_BSpline)
  ans
  
}

attr(`BSpline__SWIG_5`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline__SWIG_5`, "inputTypes") = c('integer')
class(`BSpline__SWIG_5`) = c("SWIGFunction", class('BSpline__SWIG_5'))

`BSpline` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 0) {
    f <- BSpline__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_tinyspline__BSpline') && length(argv[[1]]) == 1) {
      f <- BSpline__SWIG_1; 
    }
    else if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- BSpline__SWIG_5; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- BSpline__SWIG_4; 
    }
  } else if (argc == 3) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- BSpline__SWIG_3; 
    }
  } else if (argc == 4) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && is.character(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- BSpline__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for BSpline with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_BSpline

`delete_BSpline` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_BSpline', self, PACKAGE='tinyspliner');
  
}

attr(`delete_BSpline`, 'returnType') = 'void'
attr(`delete_BSpline`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`delete_BSpline`) = c("SWIGFunction", class('delete_BSpline'))

# Start of BSpline_Functor

`BSpline_Functor` = function(self, u, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_BSpline_Functor', self, u, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__DeBoorNet", ref=ans);
  
  ans
  
}

attr(`BSpline_Functor`, 'returnType') = '_p_tinyspline__DeBoorNet'
attr(`BSpline_Functor`, "inputTypes") = c('_p_tinyspline__BSpline', 'numeric')
class(`BSpline_Functor`) = c("SWIGFunction", class('BSpline_Functor'))

# Start of BSpline_controlPointAt

`BSpline_controlPointAt` = function(self, index)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  ;.Call('R_swig_BSpline_controlPointAt', self, index, PACKAGE='tinyspliner');
  
}

attr(`BSpline_controlPointAt`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`BSpline_controlPointAt`, "inputTypes") = c('_p_tinyspline__BSpline', 'integer')
class(`BSpline_controlPointAt`) = c("SWIGFunction", class('BSpline_controlPointAt'))

# Start of BSpline_eval

`BSpline_eval` = function(self, u, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_BSpline_eval', self, u, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__DeBoorNet", ref=ans);
  
  ans
  
}

attr(`BSpline_eval`, 'returnType') = '_p_tinyspline__DeBoorNet'
attr(`BSpline_eval`, "inputTypes") = c('_p_tinyspline__BSpline', 'numeric')
class(`BSpline_eval`) = c("SWIGFunction", class('BSpline_eval'))

# Start of BSpline_isClosed

`BSpline_isClosed__SWIG_0` = function(self, epsilon, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_BSpline_isClosed__SWIG_0', self, epsilon, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`BSpline_isClosed__SWIG_0`, 'returnType') = 'logical'
attr(`BSpline_isClosed__SWIG_0`, "inputTypes") = c('_p_tinyspline__BSpline', 'numeric')
class(`BSpline_isClosed__SWIG_0`) = c("SWIGFunction", class('BSpline_isClosed__SWIG_0'))

# Start of BSpline_isClosed

`BSpline_isClosed__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BSpline_isClosed__SWIG_1', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`BSpline_isClosed__SWIG_1`, 'returnType') = 'logical'
attr(`BSpline_isClosed__SWIG_1`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_isClosed__SWIG_1`) = c("SWIGFunction", class('BSpline_isClosed__SWIG_1'))

`BSpline_isClosed` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_tinyspline__BSpline')) {
      f <- BSpline_isClosed__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_tinyspline__BSpline') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- BSpline_isClosed__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BSpline_isClosed with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BSpline_toJSON

`BSpline_toJSON` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BSpline_toJSON', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`BSpline_toJSON`, 'returnType') = 'character'
attr(`BSpline_toJSON`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_toJSON`) = c("SWIGFunction", class('BSpline_toJSON'))

# Start of BSpline_fromJSON

`BSpline_fromJSON` = function(self, json)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  json = as(json, "character"); 
  ;.Call('R_swig_BSpline_fromJSON', self, json, PACKAGE='tinyspliner');
  
}

attr(`BSpline_fromJSON`, 'returnType') = 'void'
attr(`BSpline_fromJSON`, "inputTypes") = c('_p_tinyspline__BSpline', 'character')
class(`BSpline_fromJSON`) = c("SWIGFunction", class('BSpline_fromJSON'))

# Start of BSpline_save

`BSpline_save` = function(self, path)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  path = as(path, "character"); 
  ;.Call('R_swig_BSpline_save', self, path, PACKAGE='tinyspliner');
  
}

attr(`BSpline_save`, 'returnType') = 'void'
attr(`BSpline_save`, "inputTypes") = c('_p_tinyspline__BSpline', 'character')
class(`BSpline_save`) = c("SWIGFunction", class('BSpline_save'))

# Start of BSpline_load

`BSpline_load` = function(self, path)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  path = as(path, "character"); 
  ;.Call('R_swig_BSpline_load', self, path, PACKAGE='tinyspliner');
  
}

attr(`BSpline_load`, 'returnType') = 'void'
attr(`BSpline_load`, "inputTypes") = c('_p_tinyspline__BSpline', 'character')
class(`BSpline_load`) = c("SWIGFunction", class('BSpline_load'))

# Start of BSpline_setControlPointAt

`BSpline_setControlPointAt` = function(self, index, ctrlp)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  index = as.integer(index);
  
  if(length(index) > 1) {
    warning("using only the first element of index");
  };
  
  if (inherits(ctrlp, "ExternalReference")) ctrlp = slot(ctrlp,"ref") 
  ;.Call('R_swig_BSpline_setControlPointAt', self, index, ctrlp, PACKAGE='tinyspliner');
  
}

attr(`BSpline_setControlPointAt`, 'returnType') = 'void'
attr(`BSpline_setControlPointAt`, "inputTypes") = c('_p_tinyspline__BSpline', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`BSpline_setControlPointAt`) = c("SWIGFunction", class('BSpline_setControlPointAt'))

# Start of BSpline_insertKnot

`BSpline_insertKnot` = function(self, u, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_BSpline_insertKnot', self, u, n, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans);
  
  ans
  
}

attr(`BSpline_insertKnot`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline_insertKnot`, "inputTypes") = c('_p_tinyspline__BSpline', 'numeric', 'integer')
class(`BSpline_insertKnot`) = c("SWIGFunction", class('BSpline_insertKnot'))

# Start of BSpline_split

`BSpline_split` = function(self, u, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_BSpline_split', self, u, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans);
  
  ans
  
}

attr(`BSpline_split`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline_split`, "inputTypes") = c('_p_tinyspline__BSpline', 'numeric')
class(`BSpline_split`) = c("SWIGFunction", class('BSpline_split'))

# Start of BSpline_buckle

`BSpline_buckle` = function(self, b, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_BSpline_buckle', self, b, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans);
  
  ans
  
}

attr(`BSpline_buckle`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline_buckle`, "inputTypes") = c('_p_tinyspline__BSpline', 'numeric')
class(`BSpline_buckle`) = c("SWIGFunction", class('BSpline_buckle'))

# Start of BSpline_toBeziers

`BSpline_toBeziers` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_BSpline_toBeziers', self, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans);
  
  ans
  
}

attr(`BSpline_toBeziers`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline_toBeziers`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_toBeziers`) = c("SWIGFunction", class('BSpline_toBeziers'))

# Start of BSpline_derive

`BSpline_derive__SWIG_0` = function(self, n, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;ans = .Call('R_swig_BSpline_derive__SWIG_0', self, n, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans);
  
  ans
  
}

attr(`BSpline_derive__SWIG_0`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline_derive__SWIG_0`, "inputTypes") = c('_p_tinyspline__BSpline', 'integer')
class(`BSpline_derive__SWIG_0`) = c("SWIGFunction", class('BSpline_derive__SWIG_0'))

# Start of BSpline_derive

`BSpline_derive__SWIG_1` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_BSpline_derive__SWIG_1', self, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans);
  
  ans
  
}

attr(`BSpline_derive__SWIG_1`, 'returnType') = '_p_tinyspline__BSpline'
attr(`BSpline_derive__SWIG_1`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_derive__SWIG_1`) = c("SWIGFunction", class('BSpline_derive__SWIG_1'))

`BSpline_derive` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_tinyspline__BSpline')) {
      f <- BSpline_derive__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_tinyspline__BSpline') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- BSpline_derive__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for BSpline_derive with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of BSpline_degree_get

`BSpline_degree_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BSpline_degree_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`BSpline_degree_get`, 'returnType') = 'integer'
attr(`BSpline_degree_get`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_degree_get`) = c("SWIGFunction", class('BSpline_degree_get'))

# Start of BSpline_order_get

`BSpline_order_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BSpline_order_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`BSpline_order_get`, 'returnType') = 'integer'
attr(`BSpline_order_get`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_order_get`) = c("SWIGFunction", class('BSpline_order_get'))

# Start of BSpline_dimension_get

`BSpline_dimension_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BSpline_dimension_get', self, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`BSpline_dimension_get`, 'returnType') = 'integer'
attr(`BSpline_dimension_get`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_dimension_get`) = c("SWIGFunction", class('BSpline_dimension_get'))

# Start of BSpline_domain_get

`BSpline_domain_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_BSpline_domain_get', self, PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__Domain", ref=ans) ;
  
  ans
  
}

attr(`BSpline_domain_get`, 'returnType') = '_p_tinyspline__Domain'
attr(`BSpline_domain_get`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_domain_get`) = c("SWIGFunction", class('BSpline_domain_get'))

# Start of BSpline_controlPoints_set

`BSpline_controlPoints_set` = function(self, s_controlPoints)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_controlPoints, "ExternalReference")) s_controlPoints = slot(s_controlPoints,"ref") 
  ;.Call('R_swig_BSpline_controlPoints_set', self, s_controlPoints, PACKAGE='tinyspliner');
  
}

attr(`BSpline_controlPoints_set`, 'returnType') = 'void'
attr(`BSpline_controlPoints_set`, "inputTypes") = c('_p_tinyspline__BSpline', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`BSpline_controlPoints_set`) = c("SWIGFunction", class('BSpline_controlPoints_set'))

# Start of BSpline_controlPoints_get

`BSpline_controlPoints_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BSpline_controlPoints_get', self, PACKAGE='tinyspliner');
  
}

attr(`BSpline_controlPoints_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`BSpline_controlPoints_get`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_controlPoints_get`) = c("SWIGFunction", class('BSpline_controlPoints_get'))

# Start of BSpline_knots_set

`BSpline_knots_set` = function(self, s_knots)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_knots, "ExternalReference")) s_knots = slot(s_knots,"ref") 
  ;.Call('R_swig_BSpline_knots_set', self, s_knots, PACKAGE='tinyspliner');
  
}

attr(`BSpline_knots_set`, 'returnType') = 'void'
attr(`BSpline_knots_set`, "inputTypes") = c('_p_tinyspline__BSpline', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`BSpline_knots_set`) = c("SWIGFunction", class('BSpline_knots_set'))

# Start of BSpline_knots_get

`BSpline_knots_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_BSpline_knots_get', self, PACKAGE='tinyspliner');
  
}

attr(`BSpline_knots_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`BSpline_knots_get`, "inputTypes") = c('_p_tinyspline__BSpline')
class(`BSpline_knots_get`) = c("SWIGFunction", class('BSpline_knots_get'))

# Start of accessor method for tinyspline::BSpline
setMethod('$', '_p_tinyspline__BSpline', function(x, name)

{
  accessorFuns = list('Functor' = BSpline_Functor, 'controlPointAt' = BSpline_controlPointAt, 'eval' = BSpline_eval, 'isClosed' = BSpline_isClosed, 'toJSON' = BSpline_toJSON, 'fromJSON' = BSpline_fromJSON, 'save' = BSpline_save, 'load' = BSpline_load, 'setControlPointAt' = BSpline_setControlPointAt, 'insertKnot' = BSpline_insertKnot, 'split' = BSpline_split, 'buckle' = BSpline_buckle, 'toBeziers' = BSpline_toBeziers, 'derive' = BSpline_derive, 'degree' = BSpline_degree_get, 'order' = BSpline_order_get, 'dimension' = BSpline_dimension_get, 'domain' = BSpline_domain_get, 'controlPoints' = BSpline_controlPoints_get, 'knots' = BSpline_knots_get);
  vaccessors = c('degree', 'order', 'dimension', 'domain', 'controlPoints', 'knots');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for tinyspline::BSpline
# Start of accessor method for tinyspline::BSpline
setMethod('$<-', '_p_tinyspline__BSpline', function(x, name, value)

{
  accessorFuns = list('controlPoints' = BSpline_controlPoints_set, 'knots' = BSpline_knots_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_tinyspline__BSpline', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('controlPoints' = BSpline_controlPoints_set, 'knots' = BSpline_knots_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for tinyspline::BSpline
setMethod('delete', '_p_tinyspline__BSpline', function(obj) {delete_tinyspline__BSpline(obj)})
# Start of Utils_interpolateCubic

`Utils_interpolateCubic` = function(points, dim, .copy = FALSE)
{
  if (inherits(points, "ExternalReference")) points = slot(points,"ref") 
  dim = as.integer(dim);
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  ;ans = .Call('R_swig_Utils_interpolateCubic', points, dim, as.logical(.copy), PACKAGE='tinyspliner');
  ans <- new("_p_tinyspline__BSpline", ref=ans);
  
  ans
  
}

attr(`Utils_interpolateCubic`, 'returnType') = '_p_tinyspline__BSpline'
attr(`Utils_interpolateCubic`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`Utils_interpolateCubic`) = c("SWIGFunction", class('Utils_interpolateCubic'))

# Start of Utils_knotsEqual

`Utils_knotsEqual` = function(x, y, .copy = FALSE)
{
  ;.Call('R_swig_Utils_knotsEqual', x, y, as.logical(.copy), PACKAGE='tinyspliner');
  
}

attr(`Utils_knotsEqual`, 'returnType') = 'logical'
attr(`Utils_knotsEqual`, "inputTypes") = c('numeric', 'numeric')
class(`Utils_knotsEqual`) = c("SWIGFunction", class('Utils_knotsEqual'))

# Start of delete_Utils

`delete_Utils` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Utils', self, PACKAGE='tinyspliner');
  
}

attr(`delete_Utils`, 'returnType') = 'void'
attr(`delete_Utils`, "inputTypes") = c('_p_tinyspline__Utils')
class(`delete_Utils`) = c("SWIGFunction", class('delete_Utils'))

setMethod('delete', '_p_tinyspline__Utils', function(obj) {delete_tinyspline__Utils(obj)})

